# Advent of Code 2020

For the third time I'm trying to find out how far I can make it in [Advent of Code](https://adventofcode.com/2020/). After tapping out in 2018 after 9 days, I decided try to beat this score in 2019 - and I did, managing to solve the first 13 days, included writing a fully functional intcode computer. Then my regular professional life won and prevented me from getting deeply involved into graph-related problems.

Now it's 2020. I barely touched coding this year and with my current schedule, I thought I wouldn't have time for this kind of fun and I probably don't. 

But I decided to solve some puzzles anyway!

Things I **L**earned, **R**evised or **I**mproved at in 2020:

* [Day 1](01/d01.py): Sum of Twos (**R**) and Sum of Threes (**L**)
* [Day 2](02/d02.py): Regular expressions (**R**)
* [Day 3](03/d03.py): Modulo operations (**R**) and reduce (**I**)
* [Day 4](04/d04.py): Regular expressions (**R**) and turtle animations (**L**)
* [Day 5](05/d05.py): Binary search (**R**)
* [Day 6](06/d06.py): Set operations (**I**)
* [Day 7](07/d07.py): Recursive DFS (**L**), iterative DFS (**R**), spotting directed graphs (**I**) and representing them as dicts-of-dicts (**L**)
* [Day 8](08/d08.py): Copying nested objects in Python (**R**)
* [Day 9](09/d09.py): Sum of Twos, again (**R**) and finding subarrays which sum to a number (**L**)
* [Day 10](10/d10.py): ...that recursion is not always The Way (**R**) and that Tribonacci is a thing (**R**)
* [Day 11](11/d11.py): Finding elements in 2D arrays (**R**), using Enums in Python (**L**) in alternative (slow-as-heck) solution of pt. 2
* [Day 12](12/d12.py): Taxicab geometry a.k.a. Manhattan distance (**R**)
* [Day 13](13/d13.py): Numbers theory (**I**) including learning that the Chinese remainder theorem is a thing (**L**)
* [Day 14](14/d14.py): Permutations (**R**) and bitmasks (**I**)
* [Day 15](15/d15.py): defaultdict (**I**) and Van Eck sequence (**L**)
* [Day 16](16/d16.py): Set operations (**I**)
* [Day 17](17/d17.py): Set operations (**I**) for Conway's Game of Life in 3D (**L**)
* [Day 18](18/d18.py): Reverse Polish Notation (**R**) and the shunting-yard algorithm (**L**)
* [Day 19](19/d19.py): Recursion (**I**) and regular expressions (**I**).
* Day 20: Second star still missing. Ideas to try later: numpy array concatenation.
* [Day 21](21/d21.py): Set operations (**I**)
* [Day 22](22/d22.py): Using deque (**I**) and recursion (**I**)
* [Day 23](23/d23.py): Looped linked lists (**I**)
* [Day 24](24/d24.py): Representing a hexagonal grid with cube coordinates(**L**) for Conway's Game of Life in Hex (**L**)
* [Day 25](25/d25.py): Generators (**R**) and using pow() with mod (**L**), though neither was really necessary

As of Day 25 I have 49 stars which is totally my personal best. It seems that this year the puzzles were easier and less time-consuming than in 2019. But I did improve a little bit, I guess :)